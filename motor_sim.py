#%%
import matplotlib.pyplot as plt
import numpy as np

# --- Hyperparameters ---
class hyperparameters:
    # Motor Parameters (Adjusted R based on analysis)
    MOTOR_R = 1.5  # Resistance in ohms
    MOTOR_K_t = 0.00375 * MOTOR_R  # Torque constant in Nm/A
    MOTOR_K_e = 0.00375 * MOTOR_R  # Back EMF constant in V/(rad/s)
    MOTOR_J = 4e-5     # Rotor inertia ONLY in kg.m^2
    MOTOR_B = 1e-6     # Viscous friction coefficient in Nm.s/rad (Often negligible compared to load)
    MOTOR_V_MAX = 12.0 # Maximum voltage in volt

    # System Parameters
    PULLY_RADIUS = 0.01 # Pulley radius in meters (1 cm)
    M_CART = 0.5        # Mass of cart + pendulum in kg (500g)

hp = hyperparameters()

# --- Motor Model Function ---
def motor_model_dynamics(voltage, omega, R, K_t, K_e, J_eff, b):
    """
    Calculates the angular acceleration (dω/dt) of the DC motor
    considering the effective inertia of the motor and load.

    Args:
        voltage (float): Current input voltage (V).
        omega (float): Current angular velocity (rad/s).
        R (float): Armature Resistance (Ohms).
        K_t (float): Torque Constant (Nm/A).
        K_e (float): Back EMF Constant (V/(rad/s)).
        J_eff (float): Effective Inertia (motor + load) (kg.m^2).
        b (float): Viscous Friction Coefficient (Nm.s/rad).

    Returns:
        float: Angular acceleration (dω/dt) in rad/s^2.
    """
    # Avoid division by zero if R or J_eff are zero
    if R == 0 or J_eff == 0:
        print("Warning: R or J_eff is zero, returning zero acceleration.")
        return 0.0

    # Calculate motor torque (τ_m) generated by the motor windings
    # τ_m = K_t * I = K_t * (V - V_emf) / R = K_t * (V - K_e * omega) / R
    tau_m = (K_t / R) * voltage - (K_t * K_e / R) * omega

    # Calculate net torque available for acceleration (motor torque - friction torque)
    net_torque = tau_m - b * omega

    # Calculate angular acceleration (dω/dt = net_torque / J_eff)
    domega_dt = net_torque / J_eff

    return domega_dt

# --- Simulation and Display Function (Step Response) ---
def simulate_step_response(
    voltage_step=hp.MOTOR_V_MAX, # Input voltage step (V)
    t_final=0.5,                 # Total simulation time (s) - reduced for faster accel view
    dt=0.001,                    # Simulation time step (s) - smaller for better accuracy
    # --- Motor and System Parameters ---
    R=hp.MOTOR_R,
    K_t=hp.MOTOR_K_t,
    K_e=hp.MOTOR_K_e,
    J_motor=hp.MOTOR_J,          # Renamed to clarify it's just the motor
    b=hp.MOTOR_B,
    m_cart=hp.M_CART,
    pulley_radius=hp.PULLY_RADIUS
    ):
    """
    Simulates the DC motor and cart system response to a step voltage input
    and plots the linear acceleration and velocity of the cart.

    Args:
        voltage_step (float): The constant voltage applied at t=0.
        t_final (float): Duration of the simulation.
        dt (float): Time step for numerical integration.
        R, K_t, K_e, J_motor, b (float): Motor parameters.
        m_cart (float): Mass of the cart and pendulum.
        pulley_radius (float): Radius of the drive pulley.
    """
    print(f"--- Running Step Response Simulation ---")
    print(f"Voltage: {voltage_step} V")
    print(f"Motor R: {R} Ohms, K_t: {K_t} Nm/A, K_e: {K_e} V/rad/s, J_motor: {J_motor:.2e} kg.m^2, b: {b:.1e} Nm.s/rad")
    print(f"Cart Mass: {m_cart} kg, Pulley Radius: {pulley_radius} m")

    # --- Calculate Effective Inertia ---
    # Inertia of the linear mass reflected to the motor shaft = m * r^2
    J_load_reflected = m_cart * pulley_radius**2
    J_eff = J_motor + J_load_reflected
    print(f"Reflected Load Inertia: {J_load_reflected:.2e} kg.m^2")
    print(f"Effective Total Inertia (J_eff): {J_eff:.2e} kg.m^2")

    # --- Simulation Setup ---
    n_steps = int(t_final / dt)
    time_points = np.linspace(0, t_final, n_steps + 1)

    # Initialize state variables and history lists
    omega = 0.0  # Initial angular velocity (rad/s)
    linear_velocity = 0.0 # Initial linear velocity (m/s)
    linear_acceleration = 0.0 # Initial linear acceleration (m/s^2)

    omega_history = [omega]
    linear_velocity_history = [linear_velocity]
    linear_acceleration_history = [] # Calculated within the loop

    # --- Simulation Loop (Euler Integration) ---
    for i, t in enumerate(time_points):
        # Calculate angular acceleration using the model with J_eff
        domega_dt = motor_model_dynamics(voltage_step, omega, R, K_t, K_e, J_eff, b)

        # Calculate linear acceleration: a = alpha * r
        linear_acceleration = domega_dt * pulley_radius
        linear_acceleration_history.append(linear_acceleration)

        # Update velocity for the *next* step (Euler method)
        # Update omega first
        omega = omega + domega_dt * dt
        # Update linear velocity: v = omega * r
        linear_velocity = omega * pulley_radius

        # Store history (state *after* update for the end of the interval)
        # Skip storing for the very last time point as the loop ends
        if i < n_steps:
            omega_history.append(omega)
            linear_velocity_history.append(linear_velocity)

    # Ensure history lists match time_points length
    # The last acceleration corresponds to the state *before* the final impossible step
    # Or alternatively, calculate acceleration one last time for the final state omega
    final_domega_dt = motor_model_dynamics(voltage_step, omega_history[-1], R, K_t, K_e, J_eff, b)
    final_linear_acceleration = final_domega_dt * pulley_radius
    # Let's stick to the acceleration *during* each interval for plotting
    # So linear_acceleration_history should have n_steps elements.
    # We can plot it against time_points[:-1] or duplicate the last value. Let's duplicate.
    # linear_acceleration_history.append(linear_acceleration_history[-1]) # Approximate last value


    # --- Report Initial Acceleration ---
    print(f"\nInitial Angular Acceleration (t=0): {linear_acceleration_history[0]/pulley_radius:.2f} rad/s^2")
    print(f"Initial Linear Acceleration (t=0): {linear_acceleration_history[0]:.2f} m/s^2")
    max_linear_velocity = max(linear_velocity_history)
    print(f"Maximum Linear Velocity Reached: {max_linear_velocity:.2f} m/s")


    # --- Plotting Results ---
    fig, ax1 = plt.subplots(figsize=(12, 7))

    # Plot Linear Acceleration
    color = 'tab:red'
    ax1.set_xlabel('Time (s)')
    ax1.set_ylabel('Linear Acceleration (m/s²)', color=color)
    # Plot acceleration against the start of each time interval
    ax1.plot(time_points, linear_acceleration_history, color=color, label='Cart Acceleration (a)')
    ax1.tick_params(axis='y', labelcolor=color)
    ax1.grid(True, which='both', linestyle='--', linewidth=0.5)
    ax1.set_ylim(bottom=min(0, min(linear_acceleration_history)*1.1)) # Ensure y=0 is visible

    # Create a second y-axis for Linear Velocity
    ax2 = ax1.twinx()
    color = 'tab:blue'
    ax2.set_ylabel('Linear Velocity (m/s)', color=color)
    # Plot velocity against the end of each time interval (where the state is known)
    ax2.plot(time_points, linear_velocity_history, color=color, linestyle='--', label='Cart Velocity (v)')
    ax2.tick_params(axis='y', labelcolor=color)
    ax2.set_ylim(bottom=min(0, min(linear_velocity_history)*1.1)) # Ensure y=0 is visible


    # Add titles and legend
    plt.title(f'Cart Response to {voltage_step}V Step Input (Effective Inertia Included)')
    # Combine legends from both axes
    lines1, labels1 = ax1.get_legend_handles_labels()
    lines2, labels2 = ax2.get_legend_handles_labels()
    ax2.legend(lines1 + lines2, labels1 + labels2, loc='center right')

    fig.tight_layout()
    plt.show()
    print("--- Simulation Complete ---")


# --- Run the Simulation ---
if __name__ == "__main__":
    print("Running DC motor simulation with step voltage...")

    simulate_step_response(
        voltage_step=12.0, # Apply 12V step
        t_final=5,       # Simulate for 0.5 seconds
        dt=0.001,          # Use a small time step
        # Using parameters defined in hp class
        R=hp.MOTOR_R,
        K_t=hp.MOTOR_K_t,
        K_e=hp.MOTOR_K_e,
        J_motor=hp.MOTOR_J,
        b=hp.MOTOR_B,
        m_cart=hp.M_CART,
        pulley_radius=hp.PULLY_RADIUS
    )

    # You could also run with different parameters if needed:
    # print("\nRunning with potentially different parameters:")
    # simulate_step_response(voltage_step=6.0, R=10.0, K_t=0.025, K_e=0.025)
# %%
